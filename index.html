<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chord Finder AI â€” v9.7.6 (Harmonic Live Sheet)</title>
  <meta name="theme-color" content="#0b1022" />
  <style>
    :root{--bg:#0b1022;--panel:#0f172a;--muted:#94a3b8;--text:#e5e7eb;--card:#0a1324;--border:#1b2333;--brand:#22c55e;--accent:#38bdf8;--alert:#f59e0b}
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(160deg,var(--bg),#0a0f1c);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);direction:rtl}
    .wrap{max-width:1120px;margin:auto;padding:18px}
    h1{margin:6px 0 10px;font-size:24px}
    .muted{color:var(--muted);font-size:14px}
    .panel{background:#0c162b;border:1px solid #1f2a40;border-radius:16px;padding:14px;margin-top:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="file"], select, button, input[type="number"]{padding:10px 14px;border-radius:12px;border:1px solid #223;background:#0b1221;color:#cfe3ff;appearance:none;font-weight:700;cursor:pointer}
    .badge{display:inline-flex;gap:6px;align-items:center;background:#0b1221;border:1px solid #1f2937;color:#cbd5e1;border-radius:999px;padding:6px 10px;font-size:12px}
    .badge.ai{border-color:#23664d;background:#0d2e1f;color:#d7ffe6}
    .live{background:#0c162b;border:1px solid #1f2a40;border-radius:16px;padding:18px;display:flex;align-items:center;justify-content:space-between;margin-top:10px}
    .live .title{color:#a9b4c8;font-size:13px}
    .live .ch{font-weight:800;font-size:42px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;line-height:1.6;direction:ltr;text-align:left}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #2a3d55;margin:2px 4px;background:#0b1221}
    .ok{border-color:#1f5f3f;color:#d7ffe6;background:#0d2e1f}
    .err{border-color:#5f2323;color:#ffe0e0;background:#3f1d1d}
    .warn{border-color:#8a6a1f;color:#fff0d9;background:#3a2a0c}
    .spin{width:12px;height:12px;border-radius:50%;border:2px solid var(--accent);border-top-color:transparent;animation:sp 1s linear infinite}
    @keyframes sp{to{transform:rotate(360deg)}}
    progress{width:240px;height:10px;border-radius:8px;overflow:hidden}
    .mutedSmall{color:#94a3b8;font-size:12px}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;background:#0b1221;border:1px solid #1f2a40;font-size:12px}
    .chip .dot{width:6px;height:6px;border-radius:50%;background:#22c55e}
    .chip.warn .dot{background:#f59e0b}
    .chip.err .dot{background:#ef4444}
    /* sliders */
    .sliderRow{display:flex;align-items:center;gap:10px;margin-top:8px}
    input[type="range"]{width:220px}
    .tag{font-size:12px;color:#cbd5e1;border:1px solid #1f2a40;padding:4px 8px;border-radius:999px;background:#0b1221}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ğŸµ Chord Finder AI â€” v9.7.6 (Harmonic Live Sheet) <span class="mutedSmall">â€¢ fast start â€¢ minor-major (III/V/VII) â€¢ Bass F0 v2 â€¢ sliders</span></h1>
    <div class="muted">×©×“×¨×•×’ ×”×ª×—×œ×” ××™×™×“×™×ª ×¢× ×¤×¨×™×˜×ª ×”×’×™×˜×¨×” + ×˜×™×¤×•×œ ×‘××–×³×•×¨ ×—×¨×™×’ ×‘××™× ×•×¨ (III/V/VII) ×œ×¤×™ ×›×¨×•××”; ×‘×œ×™ ×œ×©× ×•×ª UX ×•×›×¤×ª×•×¨ "× ×ª×—".</div>

    <section class="panel">
      <div class="row">
        <input id="file" type="file" accept="audio/*,video/*" />
        <label>××¦×‘ ×”×¨×—×‘×•×ª:
          <select id="extMode">
            <option value="triad">×˜×¨×™××“×•×ª ×‘×œ×‘×“</option>
            <option value="smart" selected>×—×›× (sus/7/dim/maj7/9 ×¨×§ ×‘×•×•×“××•×ª)</option>
          </select>
        </label>
        <label>×§×•×•×× ×˜×”:
          <select id="quant"><option value="2">1/2</option><option value="4" selected>1/4</option><option value="8">1/8</option></select>
        </label>
        <label>ğŸ¸ ×§××¤×•:
          <input id="capo" type="number" value="0" min="0" max="9" style="width:80px" />
        </label>
        <button id="analyzeBtn">× ×ª×—</button>
        <button id="playBtn" disabled>ğŸ§ ×”×¤×¢×œ ×©××¢</button>
        <span class="badge">BPM: <b id="bpm">â€”</b></span>
        <span class="badge">××©×š: <b id="dur">â€”</b></span>
        <span class="badge">×˜×•× ×™×§×”: <b id="tonicBadge">â€”</b></span>
        <span class="badge">à²¸×•×œ×: <b id="keyBadge">â€”</b></span>
        <span id="aiBadge" class="badge ai" style="display:none">AI</span>
      </div>

      <div id="status" class="pill ok" style="display:none"></div>
      <div id="error" class="pill err" style="display:none"></div>

      <div class="sliderRow">
        <span class="tag">Ã—<span id="bassMulTxt">1.20</span></span>
        <input id="bassSens" type="range" min="0.8" max="1.8" step="0.05" value="1.20" />
        <span class="mutedSmall">×¨×’×™×©×•×ª ×‘×¡</span>
      </div>
      <div class="sliderRow">
        <span class="tag">Ã—<span id="decMulTxt">1.00</span></span>
        <input id="decSens" type="range" min="0.8" max="1.8" step="0.05" value="1.00" />
        <span class="mutedSmall">×¨×’×™×©×•×ª âœ¨ ×§×™×©×•×˜×™×</span>
      </div>

      <div class="row">
        <progress id="prog" max="100" value="0" style="display:none"></progress>
        <span id="progTxt" class="mutedSmall"></span>
        <span id="gateChip" class="chip warn" style="display:none"><span class="dot"></span>××—×›×” ×œ×¤×¨×™×˜×” ×××™×ª×™×ªâ€¦</span>
      </div>
    </section>

    <section class="panel">
      <h2>×ª×¦×•×’×ª ××§×•×¨×“ ×—×™ ×‘×–××Ÿ × ×™×’×•×Ÿ</h2>
      <audio id="player" controls preload="auto" crossorigin="anonymous" style="width:100%"></audio>
      <div class="live">
        <div class="title">×”××§×•×¨×“ ×›×¨×’×¢</div>
        <div class="ch" id="liveChord">â€”</div>
      </div>
      <div class="mutedSmall">×”×“×£ ×œ××˜×” × ×‘× ×” ×‘×–××Ÿ × ×™×’×•×Ÿ ×‘×œ×‘×“, ××©×××œ ×œ×™××™×Ÿ. ×™×¨×™×“×ª ×©×•×¨×” ×›×©×™×© ××ª× ×—×ª×/×§××“× ×¦×” ××• ××—×¨×™ 7 ××§×•×¨×“×™×.</div>
    </section>

    <section class="panel">
      <h2>ğŸ“ ×“×£ × ×’×™× ×” â€” ×‘×–××Ÿ ×××ª (×”×¨××•× ×™×” + ××ª× ×—×ª×)</h2>
      <div id="liveSheet" class="mono">â€”</div>
      <div class="row" style="margin-top:8px">
        <button id="resetSheet">××¤×¡ ×“×£ ×—×™</button>
      </div>
    </section>
  </div>

<script type="module">
// ===== UI refs =====
const fileEl=document.getElementById('file');
const analyzeBtn=document.getElementById('analyzeBtn');
const playBtn=document.getElementById('playBtn');
const statusEl=document.getElementById('status');
const errorEl=document.getElementById('error');
const prog=document.getElementById('prog'); const progTxt=document.getElementById('progTxt');
const gateChip=document.getElementById('gateChip');
const player=document.getElementById('player');
const bpmEl=document.getElementById('bpm'); const durEl=document.getElementById('dur');
const quantEl=document.getElementById('quant');
const capoEl=document.getElementById('capo'); const tonicBadge=document.getElementById('tonicBadge'); const keyBadge=document.getElementById('keyBadge');
const liveChordEl=document.getElementById('liveChord'); const liveSheetEl=document.getElementById('liveSheet');
const resetSheetBtn=document.getElementById('resetSheet'); const aiBadge=document.getElementById('aiBadge');
const bassSensEl=document.getElementById('bassSens'); const decSensEl=document.getElementById('decSens');
const bassMulTxt=document.getElementById('bassMulTxt'); const decMulTxt=document.getElementById('decMulTxt');

bassSensEl.oninput=()=>{ bassMulTxt.textContent=Number(bassSensEl.value).toFixed(2); };
decSensEl.oninput =()=>{ decMulTxt .textContent=Number(decSensEl.value).toFixed(2); };

function showAnalyzing(stepText){ statusEl.innerHTML='<span class="spin"></span> '+stepText; statusEl.className='pill warn'; statusEl.style.display='inline-flex'; }
function ok(msg){ statusEl.textContent=msg; statusEl.className='pill ok'; statusEl.style.display='inline-flex'; }
function err(msg){ errorEl.textContent=msg; errorEl.style.display='inline-flex'; }
function hideAlerts(){ statusEl.style.display='none'; errorEl.style.display='none'; prog.style.display='none'; progTxt.textContent=''; gateChip.style.display='none'; }

// ===== Musical helpers =====
const NOTES_SHARP=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTES_FLAT =['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
const MAJOR_SCALE=[0,2,4,5,7,9,11], MINOR_SCALE=[0,2,3,5,7,8,10];
const toPc=n=>((n%12)+12)%12;
const nameSharp=i=>NOTES_SHARP[toPc(i)]; const nameFlat=i=>NOTES_FLAT[toPc(i)];
const dot=(a,b)=>a.reduce((s,x,i)=>s+x*b[i],0);
const norm=a=>Math.sqrt(a.reduce((s,x)=>s+x*x,0))||1;
const cos=(a,b)=>dot(a,b)/(norm(a)*norm(b));
function maskVec(root, pcs){ const v=new Array(12).fill(0); pcs.forEach(iv=>v[(root+iv)%12]=1); return v; }
function parseRoot(label){ const m=label?.match?.(/^([A-G](?:#|b)?)/); if(!m) return -1; const nm=m[1].replace('b','#'); const i=NOTES_SHARP.indexOf(nm); return i<0?-1:i; }
function applyCapoToLabel(label, capo){
  if(!capo || capo===0) return label;
  const m=label.match(/^([A-G](?:#|b)?)(.*)$/); if(!m) return label;
  const idx=NOTES_SHARP.indexOf(m[1].replace('b','#')); if(idx<0) return label;
  const newPc = toPc(idx - capo);
  return nameFlat(newPc)+(m[2]||'');
}
function sanitizeLabel(lbl){
  if(!lbl) return lbl;
  return lbl
    .replace(/\\n/g,'')
    .replace(/[\\n\\r\\t]/g,'')
    .replace(/\\s{2,}/g,' ')
    .replace(/[^A-Ga-g#bm79sus24()\\/\\s]/g,'')
    .trim();
}

// ===== Krumhansl profiles =====
const KS_MAJOR=[6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
const KS_MINOR=[6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];
function ksScore(chromaAgg, root, isMinor){
  const prof=(isMinor? KS_MINOR: KS_MAJOR);
  let s=0; for(let i=0;i<12;i++){ s += chromaAgg[toPc(i+root)] * prof[i]; } return s;
}
function inKey(pc, keyRoot, minor){ const sc = minor? MINOR_SCALE: MAJOR_SCALE; return sc.includes(toPc(pc-keyRoot)); }

// ===== Stage 1: decode =====
analyzeBtn.onclick=async()=>{
  hideAlerts(); aiBadge.style.display='none';
  liveChordEl.textContent='â€”'; liveSheetEl.textContent='â€”'; playBtn.disabled=true; tonicBadge.textContent='â€”'; keyBadge.textContent='â€”';
  const f=fileEl.files?.[0]; if(!f){ err('×‘×—×¨ ×§×•×‘×¥ ××•×“×™×•/×•×™×“××•'); return; }
  try{
    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 1/4: ×˜×¢×™× ×ª ××•×“×™×•');
    const st1 = await decodeAudio(f);
    bpmEl.textContent = st1.bpm; durEl.textContent = st1.duration.toFixed(1)+'s';
    const url = URL.createObjectURL(f); player.src=url;

    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 2/4: ××™×¦×•×™ ×›×¨×•××”/×‘×¡');
    const feats = extractFeatures(st1);

    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 3/4: ×¡×•×œ× (Krumhansl) + HMM');
    const key = estimateKeyKrumhansl(feats, false, st1.duration);
    let timeline = chordTrackingWithHMM(feats, key);

    showAnalyzing('×× ×ª×—â€¦ ×©×œ×‘ 4/4: × ×™×§×•×™, ×§×™×©×•×˜×™×, ×”×™×¤×•×›×™× ×•××™× ×•×¨-××–×³×•×¨');
    timeline = finalizeTimeline(timeline, key, st1.bpm, feats);
    timeline = enforceEarlyDiatonicOpening(timeline, key, feats, st1.bpm)
               .map(ev=>({...ev, label:sanitizeLabel(ev.label)}));

    const mode = document.getElementById('extMode').value;
    const decoratedTL = decorateQualities(timeline, feats, key, mode)
                          .map(ev=>({...ev, label:sanitizeLabel(ev.label)}));

    // ×¤×•×¡×˜Ö¾×¤××¡: ×‘××™× ×•×¨ â€” ×œ×”×¤×•×š III/V/VII ×œ××–â€™×•×¨ ×× ×”-M3 ×—×–×§
    const minorFixed = adjustMinorMajors(decoratedTL, feats, key);

    const invTL = addInversions(minorFixed, feats, Number(bassSensEl.value)||1.0);

    const capo=parseInt(capoEl.value||'0',10);
    tonicBadge.textContent = applyCapoToLabel(nameSharp(key.root)+(key.minor?'m':''), capo);
    keyBadge.textContent   = applyCapoToLabel(nameSharp(key.root)+(key.minor?'m':''), capo);
    window.__STATE = { bpm: st1.bpm, duration: st1.duration, timeline: invTL, key, gateTime:detectStartGate(feats)*(feats.hop/feats.sr), energy:{t:feats.frameE.map((_,i)=> i*(feats.hop/feats.sr)), v:normalize01(feats.frameE)}, feats:{hop:feats.hop,sr:feats.sr} };

    ok('×”× ×™×ª×•×— ×”×•×©×œ× âœ“ â€” ××¤×©×¨ ×œ×”×©××™×¢');
    progTxt.textContent='';
    hookPlaybackLive(); playBtn.disabled=false; aiBadge.style.display='inline-flex';
  }catch(e){ console.error(e); err('×”×“×¤×“×¤×Ÿ ×œ× ×”×¦×œ×™×— ×œ×¤×¢× ×—/×œ× ×ª×—. × ×¡×” MP3/WAV ××• ×“×¤×“×¤×Ÿ ××—×¨.'); }
};

playBtn.onclick=async()=>{ try{ await player.play(); }catch(e){ alert('×œ×—×¥ â–¶ï¸ ×¢×œ ×”× ×’×Ÿ ×›×“×™ ×œ××©×¨ × ×™×’×•×Ÿ ×‘×“×¤×“×¤×Ÿ ×–×”.'); } };

// decodeAudio: Promise â†’ callback fallback
async function decodeAudio(file){
  const AC = window.AudioContext || window.webkitAudioContext;
  const ctx = new AC();
  try{ await ctx.resume(); }catch{}
  const arr = await file.arrayBuffer();

  try{
    const buf = await ctx.decodeAudioData(arr.slice(0));
    return postDecode(buf);
  }catch(e1){
    try{
      const buf = await new Promise((resolve,reject)=>{
        ctx.decodeAudioData(arr.slice(0), b=>resolve(b), err=>reject(err));
      });
      return postDecode(buf);
    }catch(e2){
      console.warn('decodeAudioData failed (both APIs)', e1, e2);
      throw e2||e1;
    }
  }
  function postDecode(buf){
    const mono = (buf.numberOfChannels===1)? buf.getChannelData(0) : mixStereo(buf);
    const sr0=buf.sampleRate, sr=22050;
    const x = resampleLinear(mono, sr0, sr);
    const bpm = 120;
    return { x, sr, bpm, duration: x.length/sr };
  }
}

// ===== Stage 2: feature extraction (Bass F0 v2) =====
function extractFeatures(st1){
  const {x,sr} = st1;
  const hop=Math.floor(0.10*sr), win=4096;
  const hann=new Float32Array(win); for(let i=0;i<win;i++) hann[i]=0.5*(1-Math.cos(2*Math.PI*i/(win-1)));
  const frames=[]; for(let s=0; s+win<=x.length; s+=hop) frames.push(x.subarray(s,s+win));

  function fft(input){ let n=input.length,N=1; while(N<n)N<<=1; const re=new Float32Array(N),im=new Float32Array(N); re.set(input);
    let j=0; for(let i=0;i<N;i++){ if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; } let m=N>>1; while(m>=1&&j>=m){ j-=m; m>>=1; } j+=m; }
    for(let len=2; len<=N; len<<=1){ const ang=-2*Math.PI/len, wlr=Math.cos(ang), wli=Math.sin(ang);
      for(let i=0;i<N;i+=len){ let wr=1, wi=0;
        for(let k=0;k<(len>>1);k++){
          const ur=re[i+k], ui=im[i+k];
          const vr=re[i+k+(len>>1)]*wr - im[i+k+(len>>1)]*wi;
          const vi=re[i+k+(len>>1)]*wi + im[i+k+(len>>1)]*wr;
          re[i+k]=ur+vr; im[i+k]=ui+vi;
          re[i+k+(len>>1)]=ur-vr; im[i+k+(len>>1)]=ui-vi;
          const nwr=wr*wlr - wi*wli; wi=wr*wli + wi*wlr; wr=nwr;
        }
      }
    }
    const mags=new Float32Array(N>>1); for(let k=0;k<mags.length;k++) mags[k]=Math.hypot(re[k],im[k]);
    return {mags,N};
  }

  const hz=(b,N)=>b*sr/N;
  const chroma=[], bassCand=[], frameE=[];
  for(let i=0;i<frames.length;i++){
    const y=new Float32Array(win); for(let k=0;k<win;k++) y[k]=frames[i][k]*hann[k];

    // ×× ×¨×’×™×” ×œ×¤×¨×™×™×
    let en=0; for(let k=0;k<win;k++){ en += y[k]*y[k]; } frameE.push(en);

    // ×›×¨×•××”
    const {mags,N}=fft(y);
    const c=new Float32Array(12); let eSpec=0;
    for(let b=1;b<mags.length;b++){
      const f=hz(b,N); if(f<80||f>5000) continue;
      const midi=69+12*Math.log2(f/440); const pc=toPc(Math.round(midi));
      c[pc]+=mags[b]; eSpec+=mags[b];
    }
    if(eSpec>0){ let s=0; for(let k=0;k<12;k++) s+=c[k]; for(let k=0;k<12;k++) c[k]/=s; }
    chroma.push(c);

    // ---- Bass F0 v2: ACF ×¢×œ ××•×ª LPF (â‰¤250Hz) ----
    const magsLP=new Float32Array(mags.length);
    const fmax=250;
    for(let b=1;b<mags.length;b++){ const f=hz(b,N); if(f<=fmax) magsLP[b]=mags[b]; }
    const yLP=new Float32Array(win);
    for(let b=1;b<magsLP.length;b++){
      const f=hz(b,N); if(f<=fmax){
        const omega=2*Math.PI*f/sr;
        for(let n=0;n<win;n++){ yLP[n]+=magsLP[b]*Math.cos(omega*n); }
      }
    }
    const fmin=40, f0minLag=Math.floor(sr/fmax), f0maxLag=Math.floor(sr/Math.max(1,fmin));
    let bestLag=-1, bestR=-1;
    const mean = yLP.reduce((s,v)=>s+v,0)/win;
    let denom=0; for(let n=0;n<win;n++){ const d=yLP[n]-mean; denom+=d*d; }
    denom = Math.max(denom, 1e-9);
    for(let lag=f0minLag; lag<=f0maxLag; lag++){
      let r=0;
      for(let n=0;n<win-lag;n++){
        const a=yLP[n]-mean, b=yLP[n+lag]-mean; r += a*b;
      }
      r/=denom;
      if(r>bestR){ bestR=r; bestLag=lag; }
    }
    let pcBass=-1;
    if(bestLag>0){
      const f0 = sr / bestLag;
      if(f0>=fmin && f0<=fmax){
        const midiF0 = 69 + 12*Math.log2(f0/440);
        pcBass = toPc(Math.round(midiF0));
      }
    }
    bassCand.push(pcBass);
  }

  // ×™×¦×™×‘×•×ª ×–××Ÿ: â‰¥2-3 ×¤×¨×™×™××™× (×”×•×§×œ ×œÖ¾2 ×›×“×™ ×œ×”×ª×—×™×œ ××”×¨)
  const thrE = percentileLocal(frameE, 40);
  const bassPc=new Array(bassCand.length).fill(-1);
  for(let i=1;i<bassCand.length-1;i++){
    const v=bassCand[i];
    if(v<0) continue;
    if(frameE[i] < thrE) continue;
    // ××¡×¤×™×§×™× 2 ×©×›× ×™× ×–×”×™× (i-1,i,i+1) â€” ×¤×—×•×ª ×§×©×™×— ××’×¨×¡××•×ª ×§×•×“××•×ª
    if((bassCand[i-1]===v) || (bassCand[i+1]===v)){
      bassPc[i]=v;
    }
  }

  // ×¡×’×™×¨×ª ×¨×™×¦×•×ª ×§×¦×¨×•×ª
  let runStart=-1, runVal=-2;
  for(let i=0;i<bassPc.length;i++){
    const v=bassPc[i];
    if(v>=0 && runStart<0){ runStart=i; runVal=v; }
    const end = (i===bassPc.length-1) || (bassPc[i+1]!==v);
    if(runStart>=0 && end){
      if(i-runStart+1>=2){ for(let k=runStart;k<=i;k++) bassPc[k]=runVal; }
      else{ for(let k=runStart;k<=i;k++) bassPc[k]=-1; }
      runStart=-1; runVal=-2;
    }
  }

  return { chroma, bassPc, frameE, hop:Math.floor(0.10*sr), sr };
}

// ===== Stage 3: key =====
function estimateKeyKrumhansl(feats, deep, duration){
  const {chroma}=feats;
  const L = chroma.length;
  const agg=new Array(12).fill(0);
  for(let i=0;i<L;i++){ for(let p=0;p<12;p++) agg[p]+=chroma[i][p]; }
  const s=agg.reduce((a,b)=>a+b,0)||1; for(let p=0;p<12;p++) agg[p]/=s;
  let best={score:-1, root:0, minor:false};
  for(let r=0;r<12;r++){
    const sMaj=ksScore(agg,r,false), sMin=ksScore(agg,r,true);
    if(sMaj>best.score){ best={score:sMaj, root:r, minor:false}; }
    if(sMin>best.score){ best={score:sMin, root:r, minor:true}; }
  }
  return {root:best.root, minor:best.minor};
}

// ===== Stage 3.5: HMM =====
function chordTrackingWithHMM(feats, key){
  const {chroma,bassPc,hop,sr,frameE}=feats;
  const diatonic = (key.minor? MINOR_SCALE: MAJOR_SCALE).map(s=>toPc(key.root+s));
  const candidates=[];
  for(const r of diatonic){ candidates.push({root:r,label:nameSharp(r)}); candidates.push({root:r,label:nameSharp(r)+'m'}); }

  function emitScore(i,cand){
    const c=chroma[i]; if(!c) return -Infinity;
    const isMinor = /m$/.test(cand.label);
    const mask = isMinor? maskVec(cand.root,[0,3,7]) : maskVec(cand.root,[0,4,7]);
    let s = cos([...c],mask);
    const bassMul = Number(bassSensEl.value)||1.0;
    if(bassPc[i]>=0 && cand.root===bassPc[i]) s+=0.15*bassMul;
    if(frameE[i] < percentileLocal(frameE,30)) s -= 0.10;
    return s;
  }

  const T=(a,b)=>{
    if(a.label===b.label) return 0.0;
    const dist = Math.min((b.root-a.root+12)%12,(a.root-b.root+12)%12);
    const sameQual = /m$/.test(a.label)===/m$/.test(b.label);
    let penalty = 0.6 + 0.1*dist + (sameQual?0.0:0.05);
    return penalty;
  };

  const N=candidates.length, M=chroma.length;
  const dp=new Array(N).fill(0);
  const backptr=Array.from({length:M},()=>new Array(N).fill(-1));
  for(let s=0;s<N;s++) dp[s]=emitScore(0,candidates[s]);
  for(let i=1;i<M;i++){
    const newdp=new Array(N).fill(-Infinity);
    for(let s=0;s<N;s++){
      let bestVal=-Infinity, bestJ=-1;
      for(let j=0;j<N;j++){
        const val = dp[j] - T(candidates[j], candidates[s]);
        if(val>bestVal){ bestVal=val; bestJ=j; }
      }
      newdp[s]=bestVal + emitScore(i,candidates[s]);
      backptr[i][s]=bestJ;
    }
    for(let s=0;s<N;s++) dp[s]=newdp[s];
  }
  let bestS=0, bestVal=-Infinity;
  for(let s=0;s<N;s++){ if(dp[s]>bestVal){ bestVal=dp[s]; bestS=s; } }
  const states=new Array(M); states[M-1]=bestS;
  for(let i=M-1;i>0;i--) states[i-1]=backptr[i][states[i]];
  const tl=[]; const secPerHop = hop/sr;
  let cur=states[0], start=0;
  for(let i=1;i<M;i++){
    if(states[i]!==cur){
      tl.push({t:start*secPerHop, label:candidates[cur].label, fi:start});
      cur=states[i]; start=i;
    }
  }
  tl.push({t:start*secPerHop, label:candidates[cur].label, fi:start});
  return tl;
}

// ===== Stage 4: cleanup & quantize =====
function finalizeTimeline(tl, key, bpm, feats){
  const spb=60/Math.max(60,Math.min(200,bpm||120));
  const minDur=Math.max(0.5, 0.45*spb);
  const out=[];
  for(let i=0;i<tl.length;i++){
    const a=tl[i]; const b=tl[i+1]; const dur=(b?b.t: a.t+4*spb) - a.t;
    if(dur<minDur && out.length){
      const fiA=a.fi, fiB=(b?b.fi:fiA+1);
      const bpA = feats.bassPc[fiA] ?? -1;
      const bpB = feats.bassPc[Math.min(feats.bassPc.length-1, fiB)] ?? -1;
      const bassChanged = (bpA>=0 && bpB>=0 && bpA!==bpB);
      if(!bassChanged){
        const prev=out[out.length-1];
        const r=parseRoot(a.label), pr=parseRoot(prev.label);
        const inA=inKey(r, key.root, key.minor), inP=inKey(pr, key.root, key.minor);
        if(!inA || inP){ continue; }
      }
    }
    out.push(a);
  }
  const snapped=[];
  for(const ev of out){
    const q=Math.max(0, Math.round(ev.t/spb)*spb);
    if(!snapped.length || snapped.at(-1).label!==ev.label){
      snapped.push({t:q, label:ev.label, fi:ev.fi});
    }
  }
  return snapped;
}

// ===== Early opening enforcement =====
function enforceEarlyDiatonicOpening(tl, key, feats, bpm){
  if(!tl?.length) return tl;
  const spb=60/(bpm||120);
  const earlyWindow = Math.max(3.5, 2*spb);
  const diatonicPcs = (key.minor? MINOR_SCALE: MAJOR_SCALE).map(s=>toPc(key.root+s));

  function snapToDiatonic(pc){
    let best=diatonicPcs[0],bestD=99;
    for(const d of diatonicPcs){
      const dist=Math.min((pc-d+12)%12,(d-pc+12)%12);
      if(dist<bestD){ bestD=dist; best=d; }
    }
    return best;
  }

  // ×¢×“×›×•×Ÿ ××™×›×•×ª ×œ×¤×™ ×”×§×©×¨ ×›×¨×•××”: ×‘××™× ×•×¨ ×™×™×ª×›×Ÿ ××–â€™×•×¨ ×—×¨×™×’ (III/V/VII)
  function preferQualityCtx(rootPc, fi){
    if(!key.minor){
      const rel=toPc(rootPc-key.root);
      if(rel===0||rel===5||rel===7) return '';
      if(rel===2||rel===4||rel===9) return 'm';
      return '';
    }
    const rel=toPc(rootPc-key.root);
    const i0=Math.max(0, fi-2), i1=Math.min(feats.chroma.length-1, fi+2);
    const avg=new Float32Array(12);
    for(let i=i0;i<=i1;i++){ const c=feats.chroma[i]; for(let p=0;p<12;p++) avg[p]+=c[p]||0; }
    for(let p=0;p<12;p++) avg[p]/=(i1-i0+1);
    const s=(d)=>avg[toPc(rootPc+d)]||0;
    const M3=s(4), m3=s(3);

    // ×‘××™× ×•×¨ â€” ×“×¨×’×•×ª III(2), V(4), VII(6) ×¢×©×•×™×•×ª ×œ×”×™×•×ª ××–'×•×¨ ×× M3>m3 ×‘×‘×™×¨×•×¨
    if((rel===MINOR_SCALE[2] || rel===MINOR_SCALE[4] || rel===MINOR_SCALE[6]) && (M3 > m3*1.25 && M3>0.08)){
      return ''; // ××–'×•×¨
    }
    // ×‘×¨×™×¨×ª ××—×“×œ ×©×œ ××™× ×•×¨: i, iv, v ×œ×¨×•×‘ ××™× ×•×¨
    if(rel===MINOR_SCALE[0] || rel===MINOR_SCALE[3] || rel===MINOR_SCALE[4]) return 'm';
    // ××—×¨×•×ª × ×™×˜×¨×œ×™×•×ª â€” ×‘×•×—×¨×™× ×œ×¤×™ M3 ××•×œ m3
    return (M3>m3)? '' : 'm';
  }

  const out=[];
  for(const ev of tl){
    let label = ev.label;
    if(ev.t <= earlyWindow){
      const r=parseRoot(label);
      const isIn = r>=0 && inKey(r, key.root, key.minor);
      if(!isIn){
        const bp = feats.bassPc[ev.fi] ?? -1;
        let newRoot = bp>=0 ? snapToDiatonic(bp) : snapToDiatonic(r>=0? r : key.root);
        const veryEarly = ev.t < Math.min(2.0, spb*1.5);
        if(veryEarly) newRoot = key.root;
        const q = preferQualityCtx(newRoot, ev.fi);
        label = nameSharp(newRoot) + q;
      }else{
        const q = preferQualityCtx(r, ev.fi);
        const base=nameSharp(r);
        label = base + q;
      }
    }
    out.push({...ev, label});
  }
  return out;
}

// ===== Decorations (sus/dim/m7b5/7/maj7/9) ×¢× ×¨×’×™×©×•×ª =====
function decorateQualities(tl, feats, key, mode){
  if(mode!=='smart') return tl.map(e=>({...e}));
  const mul = Number(decSensEl.value)||1.0;
  const out=[];
  for(const ev of tl){
    const root=parseRoot(ev.label); if(root<0){ out.push(ev); continue; }
    const baseTriadMinor = /m(?!aj)/.test(ev.label);
    let base = ev.label.replace(/(m|sus2|sus4|dim|aug|7|maj7|add9|9|m7b5)$/,'');
    if(baseTriadMinor) base += 'm';

    const i0=Math.max(0, ev.fi-2), i1=Math.min(feats.chroma.length-1, ev.fi+2);
    const avg=new Float32Array(12);
    for(let i=i0;i<=i1;i++){ const c=feats.chroma[i]; for(let p=0;p<12;p++) avg[p]+=c[p]||0; }
    for(let p=0;p<12;p++) avg[p]/=(i1-i0+1);

    const pc = d => toPc(root+d);
    const s = d => avg[pc(d)]||0;
    const sR = s(0);
    const sM3 = s(4), s_m3 = s(3);
    const s5 = s(7), s_b5 = s(6);
    const s2 = s(2), s4 = s(5);
    const s_b7 = s(10), s7 = s(11);

    let label = base;

    // sus
    const thirdStrong = baseTriadMinor ? (s_m3 > 0.13*mul) : (sM3 > 0.13*mul);
    const thirdWeak = !thirdStrong;
    const sus2Strong = s2 > 0.22/mul && s2 > s4*0.9;
    const sus4Strong = s4 > 0.22/mul && s4 > s2*0.9;
    if(!baseTriadMinor && thirdWeak){
      if(sus4Strong) label = base.replace(/m$/,'') + 'sus4';
      else if(sus2Strong) label = base.replace(/m$/,'') + 'sus2';
    }

    // 7 / maj7
    const domContext = (degreeOfChord(label,key)===4);
    const majContext = !/m$/.test(label) && !/sus/.test(label);
    const b7Confident   = s_b7 > 0.20/mul && s_b7 > (baseTriadMinor ? s_m3 : sM3)*0.7 && sR > 0.10/mul;
    const maj7Confident = majContext && s7 > 0.20/mul && s7 > s_b7*1.2 && (baseTriadMinor ? s_m3 : sM3) > 0.12/mul;
    if(maj7Confident){
      label = base.replace(/m$/,'') + 'maj7';
    }else if(!/sus/.test(label) && (domContext ? (s_b7 > 0.17/mul) : b7Confident)){
      if(!/7$/.test(label) && !/maj7$/.test(label)) label += '7';
    }

    // dim / m7b5
    const dimTriad = (baseTriadMinor && s_b5 > 0.26/mul && s5 < 0.12*mul && s_m3 > 0.14/mul)
                  || (!baseTriadMinor && s_b5 > 0.30/mul && s5 < 0.10*mul && sM3 < 0.08*mul);
    if(dimTriad){
      if(baseTriadMinor && s_b7 > 0.18/mul){
        label = base.replace(/m$/,'m7b5');
      }else{
        label = base.replace(/m$/,'') + 'dim';
      }
    }

    // 9 / add9
    const nineStrong = s2 > 0.25/mul && sR > 0.10/mul;
    if(/7$/.test(label) && nineStrong){
      label = label.replace(/7$/,'9');
    } else if(!/sus/.test(label) && nineStrong && (baseTriadMinor ? s_m3 : sM3) > 0.10/mul){
      if(!/maj7|7|9|add9/.test(label)){
        label += 'add9';
      }
    }

    out.push({...ev, label});
  }
  return out;
}

// ===== Minor: promote III/V/VII to major when M3 dominates =====
function adjustMinorMajors(tl, feats, key){
  if(!key.minor) return tl;
  const out=[];
  for(const ev of tl){
    let label=ev.label;
    const r=parseRoot(label); if(r<0){ out.push(ev); continue; }
    // ×”×©××¨ ×§×™×©×•×˜×™× ×›××• ×©×”× (sus/dim/maj7/7 ×•×›×•') â€” ××©× ×™× ×¨×§ m â†”ï¸ ××–â€™×•×¨ ×©×œ ×”×˜×¨×™××“
    const hasDecor = /(sus|dim|aug|maj7|7|9|add9|m7b5)/.test(label);
    const isMinor = /(^[A-G](?:#|b)?)(m)(?!aj)/.test(label);
    if(hasDecor || !isMinor){ out.push(ev); continue; }

    const rel=toPc(r - key.root);
    const degreeIsIII = (rel===MINOR_SCALE[2]);
    const degreeIsV   = (rel===MINOR_SCALE[4]);
    const degreeIsVII = (rel===MINOR_SCALE[6]);
    if(!(degreeIsIII||degreeIsV||degreeIsVII)){ out.push(ev); continue; }

    const i0=Math.max(0, ev.fi-2), i1=Math.min(feats.chroma.length-1, ev.fi+2);
    const avg=new Float32Array(12);
    for(let i=i0;i<=i1;i++){ const c=feats.chroma[i]; for(let p=0;p<12;p++) avg[p]+=c[p]||0; }
    for(let p=0;p<12;p++) avg[p]/=(i1-i0+1);
    const s=(d)=>avg[toPc(r+d)]||0;
    const M3=s(4), m3=s(3);

    if(M3 > m3*1.25 && M3>0.08){
      // ××—×œ×™×¤×™× "â€¦m" ×œÖ¾××–â€™×•×¨ ×‘×¡×™×¡×™
      label = label.replace(/m(?!aj)/,'');
    }
    out.push({...ev, label});
  }
  return out;
}

// ===== Inversions ("/E" ×•×›×•') =====
function addInversions(tl, feats, bassMul){
  const out=[];
  for(const ev of tl){
    const r = parseRoot(ev.label);
    if(r<0){ out.push(ev); continue; }

    const isMinor = /m(?!aj)/.test(ev.label);
    const isSus2 = /sus2/.test(ev.label);
    const isSus4 = /sus4/.test(ev.label);
    const triad = isSus2 ? [0,2,7] : (isSus4 ? [0,5,7] : (isMinor ? [0,3,7] : [0,4,7]));

    const bassPc = feats.bassPc[ev.fi] ?? -1;
    if(bassPc<0 || bassPc===r){ out.push(ev); continue; }

    const rel = toPc(bassPc - r);
    const inChord = triad.includes(rel);
    if(inChord){
      const c = feats.chroma[ev.fi]||new Float32Array(12);
      const confidence = (c[bassPc]||0);
      if(confidence > 0.10/Math.max(1,bassMul*0.9)){
        const rootName = ev.label.match(/^([A-G](?:#|b)?)/)?.[1]||'';
        const suffix   = ev.label.slice(rootName.length);
        const invLbl   = rootName + suffix + '/' + nameSharp(bassPc);
        out.push({...ev, label: invLbl});
        continue;
      }
    }
    out.push(ev);
  }
  return out;
}

// ===== Line breaks helpers =====
function degreeOfChord(label, key){
  const rootPc = parseRoot(label);
  if(rootPc<0) return null;
  const rel = toPc(rootPc - key.root);
  const scale = key.minor? MINOR_SCALE : MAJOR_SCALE;
  let bestDeg = null, bestDist=999;
  for(let d=0; d<scale.length; d++){
    const scPc = scale[d];
    const dist = Math.min((rel-scPc+12)%12,(scPc-rel+12)%12);
    if(dist<bestDist){ bestDist=dist; bestDeg=d; }
  }
  return bestDeg; 
}
function isCadence(prevLabel, curLabel, key){
  const dPrev = degreeOfChord(prevLabel,key);
  const dCur = degreeOfChord(curLabel,key);
  return (dPrev===4 && dCur===0);
}
function isSubdominantToDominant(prevLabel, curLabel, key){
  const dPrev=degreeOfChord(prevLabel,key);
  const dCur=degreeOfChord(curLabel,key);
  return (dPrev===3 && dCur===4);
}
function energyAt(t, energy){
  const {t:times, v:vals}=energy;
  if(!times?.length) return 0;
  let lo=0, hi=times.length-1;
  while(lo<hi){
    const mid=(lo+hi)>>1;
    if(times[mid]<t) lo=mid+1; else hi=mid;
  }
  const i=Math.max(0,Math.min(times.length-1,lo));
  return vals[i];
}
function normalize01(arr){
  if(!arr?.length) return [];
  let mn=Infinity,mx=-Infinity;
  for(const v of arr){ if(Number.isFinite(v)){ if(v<mn) mn=v; if(v>mx) mx=v; } }
  const d=(mx-mn)||1;
  return arr.map(v=> (v-mn)/d );
}

// ===== Live playback =====
function hookPlaybackLive(){
  const st=window.__STATE; if(!st) return;
  const capo=parseInt(capoEl.value||'0',10);
  const spb=60/(st.bpm||120);
  const minPauseSec=Math.max(1.0, 1.75*spb);
  const maxPerLine=7;

  let lines=[]; let currentLine=[]; 
  let lastChord=null; let lastChangeSec=0;
  liveSheetEl.textContent='â€”';
  gateChip.style.display='inline-flex';

  player.ontimeupdate=()=>{
    const t=player.currentTime;
    if(t < st.gateTime){ liveChordEl.textContent='â€”'; return; }
    if(gateChip.style.display!=='none') gateChip.style.display='none';

    let i=st.timeline.findIndex(x=>x.t>t);
    if(i===-1) i=st.timeline.length;
    const ev=st.timeline[i-1]||st.timeline[0];
    if(!ev) return;
    const shown = sanitizeLabel(applyCapoToLabel(ev.label, capo));
    liveChordEl.textContent = shown;

    if(shown!==lastChord){
      const pause = (t-lastChangeSec) > minPauseSec;
      const eNow = energyAt(t, st.energy);
      const ePrev = energyAt(Math.max(0,t-0.4), st.energy);
      const energyDrop = (ePrev>0.25 && (eNow < ePrev*0.55));

      const cadenceBreak = lastChord ? isCadence(lastChord, shown, st.key) : false;
      const sdToDom = lastChord ? isSubdominantToDominant(lastChord, shown, st.key) : false;

      const needBreak = 
          (currentLine.length>=maxPerLine)
          || cadenceBreak
          || (pause && energyDrop)
          || (sdToDom && currentLine.length>=4);

      if(needBreak && currentLine.length){
        lines.push(currentLine.join('   '));
        currentLine=[];
      }

      currentLine.push(shown);

      const text=[...lines, currentLine.join('   ')].filter(s=>s && s.length).join('\n');
      liveSheetEl.innerText = text || 'â€”';

      lastChord=shown;
      lastChangeSec=t;
    }
  };

  resetSheetBtn.onclick=()=>{
    lines=[]; currentLine=[]; lastChord=null; lastChangeSec=player.currentTime;
    liveSheetEl.textContent='â€”';
  };
}

// ===== NoiseGate (start only) â€” ×¨×’×™×© ×™×•×ª×¨ ×›×“×™ ×œ× ×œ×¤×¡×¤×¡ ××ª ×”××§×•×¨×“ ×”×¨××©×•×Ÿ =====
function detectStartGate(feats){
  const {frameE,bassPc,chroma}=feats;
  const N=frameE.length;
  const energies=[...frameE].filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);
  const med = energies[Math.floor(energies.length*0.5)] || 0;
  const thr = med*1.4;             // ×”×™×” 1.8 â†’ ×¢×›×©×™×• 1.4
  const needStable=2;              // ×”×™×” 3 â†’ ×¢×›×©×™×• 2 (×”×ª×—×œ×” ××”×™×¨×”)
  let run=0;
  for(let i=0;i<N;i++){
    const strong = frameE[i]>thr;
    const hasBass = bassPc[i]>=0;
    let chromaPeak=false;
    if(chroma[i]){
      let mx=0; for(let k=0;k<12;k++) mx=Math.max(mx, chroma[i][k]||0);
      chromaPeak = mx>0.20;       // ××¢×˜ ×¨×’×™×© ×™×•×ª×¨
    }
    // ×× ×™×© ×‘××¡ ××• ×›×¨×•××” ×—×–×§×” â€” ×œ× ××—×›×™× ×‘×›×œ×œ
    if(hasBass || chromaPeak){ return Math.max(0, i-1); }

    if(strong){ run++; if(run>=needStable) return i-needStable+1; }
    else run=0;
  }
  return 0;
}

// ===== Utils =====
function mixStereo(buf){ const a=buf.getChannelData(0), b=(buf.numberOfChannels>1?buf.getChannelData(1):a); const m=new Float32Array(buf.length); for(let i=0;i<buf.length;i++) m[i]=(a[i]+b[i])*0.5; return m; }
function resampleLinear(x,sr,target){ const r=target/sr, L=Math.floor(x.length*r), y=new Float32Array(L); for(let i=0;i<L;i++){ const t=i/r, i0=Math.floor(t), i1=Math.min(x.length-1,i0+1), a=t-i0; y[i]=x[i0]*(1-a)+x[i1]*a; } return y; }
function percentileLocal(arr, p){ const a=[...arr].filter(x=>Number.isFinite(x)).sort((x,y)=>x-y); if(!a.length) return 0; const i=Math.floor((p/100)*(a.length-1)); return a[i]; }
</script>
</body>
</html>